\chapter{Lighting Controller}
The first element of the system to be developed once the project began was the lighting controller.
This part of the project was built from scratch, as there was no prior work that had been done in this area.
This made it perfect for the first half of the year,
as other sections of the project required hardware that was currently being developed by the students finishing mid-year.

The lighting controller has a simple function in this system; it maps processed biosignals to lighting position and intensity.
Therefore, it should be able to communicate with the off-body PC and pass various commands through to whatever lights are connect to it.

Different protocols for controlling various lighting fixtures exist.
To determine which should be used for this project, a decision matrix, shown in~\autoref{tab:decision} and~\autoref{tab:decision_cont} was used.
For this project, DMX512 (DMX) was determined to be the most appropriate.

\begin{table}[!ht]
    \caption{Lighting protocol decision matrix}\label{tab:decision}
    \centering
    \input{chapters/project_plan/tables/lighting.tex}
\end{table}

\begin{table}[!ht]
    \caption{Lighting protocol decision matrix (continued)}\label{tab:decision_cont}
    \centering
    \input{chapters/project_plan/tables/lighting_continued.tex}
\end{table}

% TODO: ADD PURCHASED VS DIY CONTROLLER DECISION MATRIX
To control DMX fixtures, there are two options, using an off-the-shelf controller or creating a custom controller.
As shown in this decision matrix, the more viable option was to purchase an off-the-shelf controller.

\section{Prototyping Fixture}
To aid in the development of the lighting controller, a prototyping fixture was developed.
This fixture just requires an Arduino and a NeoPixel LED strip to function.
This has the major benefit over a real fixture of being extremely cost effective, as well as being small, and powered over USB.

The prototyping fixture is made up of 8 NeoPixel LEDs with 4 DMX channels each.
The DMX channels are intensity, red channel, green channel, blue channel.
This makes a total of 32 channels (\(4 \times 8\)) for the 8 LEDs.

\subsection{DMX}
The fixture connects to the off-body PC over USB and communicates via serial.
While the device does not strictly require DMX frames in order to function,
DMX was still implemented in software in order to better understand the protocol as well as unify the prototyping fixture with the real controller.

\subsection{NeoPixels}
The prototyping fixture contains an array of NeoPixel LEDs.
These LEDs are controlled using the Adafruit NeoPixel library~\cite{NeoPixel}.
The LEDs can then be colored independently using red, green, and blue values.
Since each color is represented using a byte, it can be mapped directly to a DMX channel, since those are also a byte long.

\subsection{Integration}
To implement DMX intensity control, the LED brightness needs to be mapped using the the code shown in~\autoref{code:dmx_mapping}.

\begin{lstlisting}[language=C++,caption={Prototyping fixture DMX color intensity mapping}\label{code:dmx_mapping}]
  (intensity * color) >> 8;
\end{lstlisting}

In this case bit shifting by 8 is equivalent to dividing by 255.
This means that at maximum intensity the result of this calculation is the color value.
While at the minimum intensity the calculation becomes 0.

The value of each LED is encoded across 4 bytes.
So the main DMX processing loop increments by 4 each time,
and extracts the discrete bytes, setting the base address of the LED to the derived color.
Once this is done for all the LEDs, they are updated using the NeoPixel show() function.

With this, the prototyping fixture can respond to DMX channels in the same way you would expect a conventional DMX fixture to.

\section{OpenDMX Controller}
For use in professional lighting environments, it is important to use compliant hardware,
since many of the devices in these environments come with a substantial cost.

Therefore, for this project a third-party device was used in order to mitigate the risk associated towards these devices.
The third-party device that was chosen was the ENTTEC OpenDMX USB device~\cite{ENTTEC},
as it was within the system budget, has an open source driver, and maintained compliance.

\subsection{Interface}
The driver provided by the manufacturer was written in C\#.
Since existing code for this project had been written in MATLAB.
An interface between the device and the existing code had to be created.
The simplest way to do this is to create a TCP/IP port that connects to a C\# server.
That way, any high level language can connect and control the DMX output device, including MATLAB.

The code for doing this is shown in~\autoref{code:dmx_server}

\lstinputlisting[language=C,caption={C sharp DMX server receiver code}\label{code:dmx_server}]{chapters/development/dmx_server.cs}
