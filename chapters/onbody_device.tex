\chapter{On-Body Device}
The on-body device was developed by William Tran in 2021 and consists of two microcontrollers,
a PIC32 and a ESP32, as well as 24-bit ADC for taking biosignal measurements.

At the middle of the year when the project was handed over,
the ESP32 had been programmed to connect to WiFi, but was only programming intermittently,
and the PIC32 had barebones programming on it to enable the ESP32 via the enable pin.

The only other contributions were from Craig Dawson who supplied information and code for programming the PIC32,
as well as attaching wires to specific pins of the PIC32, allowing it to be probed using an oscilloscope.


\section{ESP32}
The ESP32 on the board is the \textbf{ESP MODEL}.
This device is used as a wireless brige between the on-body device and the off-body PC.
It connects to the PIC32 through a Serial Peripheral Interface (SPI) bus.
It is programmed using the Arduino software enviroment.

\subsection{Power}
As stated, the ESP32 was only programming intermittently.
To determine what the cause of this unwanted behaviour was,
the board was tested in the following states in order to measure changes in how the ESP32 programmed.

\begin{itemize}
        \item The board was connected to a lab bench power supply with a non-restrictive current limit.
        \item The boot select switch was held for the extent of the programming cycle.
        \item The boot select switch was held until programming began.
        \item The boot select switch was held from when the device was powered on until programming ended.
        \item The board was powered from a lab bench power supply as well as via USB through an ICD3.
        \item All the same boot select switch options were repeated with the additional power being supplied.
\end{itemize}

From this testing, it was discovered that the ESP32 programs succesfully when it is being adequately powered
and the boot select switch is pressed as the device is being powered on.

The additional power requirement is not due to any external limitations with the power supply,
as the current draw that the supply is measuring is significantly less than the current limit.
Additionally, there is a reduction in current draw from the first supply once the additional power supply is added.
This means that the load is being shared between the two supplies,
as opposed to the first supply being at its max and the second supply provided neccessary additional power.

What his means more broadly is that the problem with programming the device comes from the power distribution of the on-body device.
This can be further verified by measuring the voltage at points on the on-body device.
All of the ICs on the device operate at a 3.3V power level.
When measuring the voltage at the input pins of the ICs and at headers around the board, the voltage appears to be closer to 2.6V.
As we add addtional voltage connections, we can observe the voltage rise.
Although the voltage does not reach 3.3V, the increase in voltage appears to be enough for the ICs to remain powered on.
This appears to be because the power traces on the board are not wide enough.
Because of this, the traces have significant resistance which causes a voltage drop to occur across them once the higher IC currents begin to flow.

For the ESP32, the lower voltage causes a brownout detection feature of the device to activate, causing it to reset.
The effect that has on the device is that it will reset itself out of programming mode, causing the programming to fail.
This is because the ESP32 must be put into programming mode by holding down the boot select switch while the device is initially powered on.
So, even in instances when the device has been succesfully put into this mode,
the device reset caused by the brownout detector reverts it out of this mode.

Once the power supply was supplimented with additional power supplies, this issue became less problematic.
However, an additional issues arose as the ESP32 has to be placed into programming mode as it is powered.
With the addition of these power supplies, there is coordination required in order to get it into this mode.
Since the power is also required to keep the ESP32 from resetting, all of the supplies need to be disconnected and reconnected at the same time,
while the boot select switch is pressed.
Additionally, with this setup there is not way to validate the correct entry into programming mode,
meaning there is not way to know if it has actually been placed into the correct mode until the programming fails.
For prototyping, this becomes extremely cumbersome because this process must be repeated every time there is a change.
As well as whenever the programming fails due to an unexpected reset.

\subsection{Over-The-Air Programming}
\ref{https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=5a31727b9b9e5f6a01f5f33a97f787f3db630b32}
When compared to the alternative, Over-The-Air (OTA) programming has a number of benefits.

\begin{itemize}
        \item The device can be programmed regardless of the boot mode.
        \item The device can be programmed without the use of a UART converter.
        \item The device can be programmed without a physical connection to a PC.
\end{itemize}

The downsides to this programming mode is that it adds additional compilation time, as well as runtime time \textbf{?}.
However, the compilation time is already in the range of 40 to 50 seconds, and the addition is less than 5 seconds.
Considering these benefits and drawbacks, it was determined that this programming mode should be implemented.

The first step in implementing this feature was to connect the device to the network.
The ESP32 is programmed using the Arduino IDE, which contains a WiFi library for the ESP32.
The code for simple WiFi device bringout is shown in~\autoref{code:wifi}.

\begin{lstlisting}[language=C++,caption={Arduino code for connected ESP32 to WiFi}\label{code:wifi}]
  #include <WiFi.h>

  void setup() {
    Serial.begin(115200);
    Serial.println('Booting');
    WiFi.mode(WIFI_STA);
    WiFi.begin(SSID, PASS);

    while (WiFi.waitForConnectResult() != WL_CONNECTED) {
      Serial.println(''Connection Failed! Rebooting...'');
      delay(5000);
      ESP.restart();
    }

  }
\end{lstlisting}

Once the device has been connected to the network, OTA programming can be implemented using the ArduinoOTA library.
This consists of including the ArduinoOTA.h header file,
configuring OTA updates using the code shown in~\autoref{code:ota},
and calling ArduinoOTA.handle() in the primary loop of the program.

\begin{lstlisting}[language=C++,caption={Arduino code for configuring OTA updates}\label{code:ota}]
  ArduinoOTA
  .onStart([]() {
    String type;

    if (ArduinoOTA.getCommand() == U_FLASH)
      type = ``sketch'';
    else // U_SPIFFS
      type = ''filesystem'';

  });

\end{lstlisting}

After implementing these libraries, the ESP32 can be programmed using OTA by selecting the relevant device.
One caveat of this is that the OTA updates will only be pushed as long as the OTA handler is called.
So, for instances where the ESP32 is in an infinite loop, or when there is a substantially long delay in the primary loop,
the ESP32 will need to be programmed using the original hardware method.


\section{PIC32}
The PIC32 on the board is the PIC32MX775F512H.
It connects to sensors, the 24-bit ADC, and the ESP32.
It is the main processor on the on-body device and it is programmed in C using MPLAB X v5.00 with an ICD 3.
The ICD 3 must be supplying 3.3V to on-body device in order for the PIC32 to be programmed succesfully.

\subsection{Programming Configuration}
The board designed by Tran \textbf{(REFERENCE HERE)} was designed in 2021.
When the board was being manufactured, there was a global supply chain issue \textbf{(REF?)}.
Because of this, the schematic design of the board was different to what was assembled on the board.
This caused issues when programming the PIC32, because the specific model of PIC had changed.
So, when the programmer connected to the device, it would read a different device ID from what was expected,
and the programming would fail.
Updating the project to use the PIC32MX775F512H solved this programming issue.

The other hurdle in programming the PIC32 was in the clock configuration.
With incorrect clock configuration, the device still programs, but it is not able to be put into debug mode.
Additionally, all intentional delays are based on the clock speed so it must be set correctly for the delays to be correct.

The clock configuration uses PLL~\ref{https://www.ijert.org/phase-locked-loop-a-review}.
It has been configured with a input divider of 10, a multiplier of 16, and an output divider of 8.
With a 16 MHz crystal, the system clock frequency becomes \textbf{CALCULATE}.
\((16 MHz / 10 * 16) / 8 = 50 MHz\)

The system clock frequency was verified by measuring the delay between pulses using an oscilloscope.
The code for delays in the system is shown in~\autoref{code:delay}, and code for generating output pulses is shown in~\autoref{code:pulses}

\begin{lstlisting}[language=C,caption={PIC32 code for adding delays in code execution (in microseconds)}\label{code:delay}]
  void delay_us(unsigned int us) {
    us *= DELAY_CONST;              // DELAY_CONST = SYS_FREQ / 1000000 / 2
    _CP0_SET_COUNT(0);              // Reset Core Timer
    while (us > _CP0_GET_COUNT());  // Wait until Core Timer reaches desired number of clock ticks
  }

  void delay(int ms) {
    delay_us(ms * 1000);
  }
\end{lstlisting}

\begin{lstlisting}[language=C,caption={PIC32 code for measuring system clock speed using delayed pulses}\label{code:pulses}]
  #define TP7 PORTDbits.RD5 // Pin definition for test point 7

  void run() {
    TP7 = 1;
    delay(100);
    TP7 = 0;
    delay(100);
  }
\end{lstlisting}

The measured results for this are shown on the oscilloscope image seen in \textbf{(FIGURE OF SCOPE HERE)}
This figure shows a 100 ms delay between pulses.
This is exactly what the software delay has been set to, which verifies that the system clock frequency has been set correctly,
because the delay relies on the system frequency to calculate the desired amount of clock ticks to wait.

With the system clock frequency set correctly, debugging works on the device and the CPU can be halted and stepped through instructions as the program is running.

\subsection{ESP32 Control}
The ESP32 is controlled by the PIC32 in two ways.

\begin{itemize}
        \item The ESP32 enable pin is connected to pin 14 (RB2) of the PIC32.
        \item The ESP32 HSPI bus is connected to SPI2 of the PIC32
\end{itemize}

The enable pin of the ESP32 just needs to be asserted high, which can be done by the PIC32 using the code shown in~\autoref{code:esp_en}

\begin{lstlisting}[language=C,caption={PIC32 code for enabling the ESP32}\label{code:esp_en}]
  void ESP32_IO_init() {
    TRISBbits.TRISB2 = 0;       // Set ESP32 EN pin as output
    PORTBbits.RB2 = 1;          // Set ESP32 EN pin high
  }
\end{lstlisting}

Without this assertion, the ESP32 is unresponsive to programming and does not perform code execution.

The other form of control is through the respective SPI lines of the two microcontrollers.
The SPI driver for the PIC32 is simple, as that device acts as the `master', which is the typical mode for a microcontroller to operate in.
The PIC32 is configured as a 32-bit master operating in SPI mode 0~\ref{https://www.sciencedirect.com/science/article/abs/pii/B9780123914903000047}
The boardrate generator value has been calculated using the equation \(BRG = (F_{PB} / 2 \times F_{SCK}) - 1\). \textbf{CALCULATE THIS: BRG = 50}.
Finally, the low-level SPI driver is implemented in~\autoref{code:spi_driver}

\begin{lstlisting}[language=C,caption={PIC32 low-level SPI driver}\label{code:spi_driver}]
  uint32_t ESP32_SPI_write(uint32_t data) {
    SPI2BUF = data;                 // Place data we want to send in SPI buffer
    while(!SPI2STATbits.SPITBE);    // Wait until sent status bit is cleared
    uint32_t read = SPI2BUF;        // Read data from buffer to clear it

    delay_us(5000);                 // Required delay for data transmission
    return read;
  }
\end{lstlisting}

The function of the code is relatively straightforward.
The memory location of the SPI2BUF variable is mapped to the SPI 2 peripheral.
When written to, the data at this address is written into a transmit buffer that queues the data for SPI transmission.
When read from, data that has been received by the SPI peripheral is taken from the receive buffer.
Between these two operations the processor waits for the SPITBE status flag to be set.
This flag corresponds to the transmission buffer being empty, and is set once transmission has been completed and data has been received.

Additionally, a delay is required between SPI writes in order to stop data from becomming corrupt.
This delay was embedded into the low-level driver to make eventual performance optimisation centralized,
since this delay is a clear cost to performance and by far the cause of the most communication slowdown.
This delay is most likely necessary due to the operation of the SPI chip select line.
Specifically, the way the chip select line does not reset between SPI transmissions without adequate delays between writes.
This could be solved by manually asserting the chip select line instead of allowing the peripheral to control it.
However, due to time restrictions it was decided that features should be prioritized over performance,
and thus the driver was implemented using significantly slower delay.

The ESP32 SPI configuration was less straightforward.
As microcontrollers are typically the devices that coordinate communication between various `dumb' sensors,
they almost always act as the SPI master.
However, since the on-body device uses multiple microcontrollers communicating via SPI,
one of these devices needs to act as a slave.
Since the PIC32 is what communicates to the sensors, and the ESP32 only acts as a wireless transmitter,
the PIC32 was configured as the SPI master, leaving the ESP32 as an SPI slave.
There no official support for this in the native development enviroment, so either a custom or third party library must be used.
In the interest of getting as much of the project functional as possible, it was decided that a third party library would be used \textbf{DECISION MATRIX?}.
However, there are potential peformance improvements that could be achieved if a custom library was used, such as reducing the PIC transmission delays,
so it is recommended that this option is looked into in the future.

The library that was used is the ESP32DMASPI~\ref{https://github.com/hideakitai/ESP32DMASPI} library.
This library is based on the official driver from the manufacture~\ref{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/spi_slave.html#spi-slave-driver}.

How do I describe my workarounds in order to get this to work aside from just saying that that's what I did?
SPI implemented using task based DMA receiving.
Tasks run in seperate threads, which frees up main thread to only process OTA updates.
One task runs continously waiting for SPI transmission~\autoref{code:esp_spi}.

\begin{lstlisting}[language=C++,caption={ESP32 code for receiving SPI data}\label{code:esp_spi}]
  void task_wait_spi(void* pvParameters) {
    while (1) {
      ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
      slave.wait(buffer, BUFFER_LENGTH);
      xTaskNotifyGive(task_handle_process_buffer);
    }
  }
\end{lstlisting}

Once data has been received, a different task handles processing the incomming data~\autoref{code:esp_spi_processing}.

\begin{lstlisting}[language=C++,caption={ESP32 code for processing SPI data}\label{code:esp_spi_processing}]
  void task_process_buffer(void* pvParameters) {
    while (1) {
      ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
      print_array(buffer, slave.available());
      slave.pop();
      xTaskNotifyGive(task_handle_wait_spi);
    }
  }
\end{lstlisting}

\textbf{DESCRIBE MORE DETAIL ABOUT HOW THESE WORK.}

This should have been the end of the SPI implementation,
however the SPI communication did not work with just this code.
To get the communication working some additional functions were required on the PIC~\autoref{code:spi_additional_functions}.

\begin{lstlisting}[language=C++, caption={PIC32 additional SPI functions}\label{code:spi_additional_functions}]
  void ESP32_SPI_write_4byte(uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4) {
    uint32_t word = ((uint32_t)b1 << 24)
                  | ((uint32_t)b2 << 16)
                  | ((uint32_t)b3 << 8)
                  | (uint32_t)b4;

    ESP32_SPI_write(word);
  }

  void ESP32_SPI_write_byte(uint8_t data) {
    ESP32_SPI_write_4byte(data, 0, 0, 0);
  }
\end{lstlisting}

Then, the only way to send data was to write a single byte at a time.
What is interesting about this is that the single byte is located at the front of the 4 byte word.
This implies that the ESP32 was not able to receive 32-bits, and instead was just receiving the first 8-bit word.
However, if the SPI peripheral of the PIC32 was put into 8-bit mode (and all respective code changed to fit that mode),
the ESP32 would receive nothing.
So, the ESP32 required the PIC32 to send 32 SPI clock pulses but would only receive the first 8 data bits.
This same behaviour was also present when using a task based approach or a polling approach and when DMA was or was not in use.
It is a substantial issue because it adds a 75\% overhead to the communication system.
This, and the required delay in the low-level driver, are the primary candidates for future optimisations.

However, despite these performance issues, the drivers function together.
Allowing abritary bytes to be shared between the two devices.


\section{ADS1294R}
The ADS1294R is a 4 channel, 24-bit, delta-sigma analog-to-digital converter with additional features to support electrocardiogram and electroencephalogram measurements.
This device is the primary sensor front end.
It communicates with the PIC32 via SPI as well as several hardware control lines.

\subsection{Design Differences}
Like the PIC32, the schematic for the ADS1294R were slightly different to what was assembled due to chip shortages.
The schematic showed the devices as an ADS1298R, which is the 8 channel version of the device.
This is significant because the device requires a specific number of SPI clock pulses to be sent that correlates to the number of channels on the device.
So sending the wrong number of clock pulses will generate undesired results.
Additionally, the device ID is different which can cause some confusion when intially trying to configure the device.

\subsection{SPI}


Also appears to be additional connection from nDRDY to DGND with some capacitors.

Not 100\% sure if this is actually happening though because only image of PCB design
low res screenshot of only top side of board. Very hard to follow traces.
As far as I can tell it seems reasonable that each trace routed from the PIC to the ADS
is correct. Not really possible to check as it is a ZXG package (basically a BGA package).

Also pin 43 of the PIC is connected to DOUT which according to the datasheet of the PIC
is actually the SPI chip select pin not the data input pin.

Might have to write a custom driver that just pulls whatever pin the actual chip select
is connected to low, writes whatever the equivalent SCK pin is high and write/reads
the corresponding SDO and SDI pin manually.

Not sure if any of this is actually managable anyway because the reset switch
is a push button and doesn't appear to have any way of switching it via the PIC.

Can't even really tell where the reset pin goes because it is grounded to the sleve of
the 3.5mm jack?!? Whatever is routed to the switch is on the underside of the board
that I don't have access to.

Currently trying to change all the configurations to see if any combinations work better.
If this doesn't work I can look at the actual altium schematics I got from Kenneth.
Thinking first I'll just try and get the actual ID from the chip
since it is easy to verify.
Going to play around with the driver, add delays between reads and writes and try different
SPI configs to see if anything makes it respond.
Also will try same thing after physically pressing reset switch because maybe it needs
hardware reset.

My scope probe wasn't working because of the x10 setting on the probe was x1.
I actually have managed to get something out of the ID register.

It should be    11010000
It actually is  01100000

This was gotten by setting SPI bits SMP = 0, CKE = 1, CKP = 0, and pressing
the reset button for the chip while using the scope to send a signal at the moment it
would have to be reset in software.
Managed to repeat this at least one more time. Attempting without pressing hardware reset.
Still works without hardware switch being pressed. Not correct but better than nothing.
Only thing that I changed was using the scope to correctly set the delay constant.

Used scope to measure space between pulses then set a specific pulse delay.
I think previously the delay number was overflowing potentially because it was so large.
Potentially the delay was way too short and the timing wasn't correct.

Can get 11000000 if I set SMP = 1
Still missing bit 4 which should be 1 no matter what.
Trying without hardware reset. Still works.

Setting CKP causes ID to be 0, so that should 100\% be reset.

Resetting it and running again causes ID to be 0
Pressing reset while it's running fixes the issue.
Still not what it 100\% should be but it's close.

Increasing the delay amount did not change anything.
Seems like hardware reset can be pressed midrun and it recovers nicely

Without delays it often does not read correctly.
Going to add a single delay in the SPI write function to set max speed.

Going to reduce the delays in the init function. Everything seems to work fine.
Going to try and remove them completely. Seems to work correctly still.
Appears that the singular delay in the SPI write function was enough and nothing else
needs it now. Probably good to do this with the ESP SPI write so that the delays are
only in a single place and can be easily optimised.

Added a substantial amount of extra delay to both to guarantee consistency, can easily
be optimised later.

Changing SPI3BRG as well to see if that makes any kind of difference.
Seems like it can be about any value and it still works the same.
Calculations say it should be greater than 2 so I'll set it to 4 for safety.
However, still works without propogating errors with a value of 1 which
should be too fast.

Wondering if the GPIO init I am doing has an effect. Turning it off causes ID to be 0.
Which is good because it means that I am actually doing something.

Going to go through init function and see what turning various things on/off
causes the system to do.
`CLK\_SEL = 0' causes the chip to stop responding.
Not writing SDATAC doesn't appear to change anything but that could be because I'm not
doing anything that needs registers set.
`START\_PIN = 0' causes chip to stop responding.

Ok now that I have a baseline that I can consistenly get to I'm going to try and do more.


\subsection{Reading Data}
When reading data it doesn't seem like the DRDY pin ever actually goes low.
Even when not sending read data continuous it is always high.
Not really sure if I can trust this though because the pin isn't exposed
So I'm setting a test point high if it is read high by the microcontroller and it may
just be staying high because by the time it can poll again it has already read all the data
and thus the chip is ready to put more data out.

Going to see what happens when I try and read without setting RDATAC.
Ok so issue now is that I am always reading 11000000 even when not reading the ID.

This is really strange to me because it should be shorted so reading 0.
Wonder if that also means that the ID I was reading is not actually correct since it wasn't
exactly what it should have been anyway and it matches what the chip sends continuously.

From my calculations I am reading 15 bytes which is 120 bits which I belive is correct.
If I don't short the input it is still 11000000

Ok so something definitly not right because even once read a few bytes the `DRDY'
pin is still high when it should be low.

It's strange because the DRDY pin is active low, in software I am checking `DRDY\_PIN == 0'
which made me think that maybe the chip just isn't on at all hence why I'm always seeing
`data\_ready()' as true.
But this isn't the case since it becomes false if I hold down the reset pin.
Which means the physical pin is being pulled high when the chip is put into reset which
seems super strange to me because I would assume everything would just go to 0.
At least in this case I can confirm that it is actually working.

It seems wrong that sending the stop data read continuous command doesn't stop the chip
from setting it's data ready pin. Not super logical to me because shouldn't that only be
true when the data is continuously being streamed.

I think the fact I am getting 192 (AKA 11000000) all the time, probably means that all the
register writes I am doing are not actually correct. What I should do I think is go back
to the ID register and attempt to get that to send correctly.

I am not entirely sure where I should start because it seems like this should be working.
I'm going to go back to the SPI config and see what I can maybe do.

Also might be worth looking at software libaries for Arduino to see what they do in say
a simple ID test script.
Maybe there is something here I am missing that is really obvious.

I think it is the power-on timing. Most likely due to hte lack of /RESET pulse since
that was never connected to the PIC.

Considering that, I think it's fair to assume that the timings may still be too short.
Might be worth looking at existing Arduino library for how they setup their SPI.
Also worth looking at schematics to verify there weren't any revision changes with how
the chip RESET is connected (although I doubt there would be).

Looking at presumably functional Arduino library:
clock polarity 0, clock phase 1, output edge rising, data capture falling

What this actually means:
Idles on logic low, data transmission from clock idle to clock active,
data shifted out on rising clock edge, data sampled on falling clock edge

\textbf{ADDITIONALLY}: Data is MSB first with a datarate of 4,000,000 (AKA 4MHz)

Also just realised it doesn't actually matter what I set the baudrate generator to because
the system clock is 5Mhz so it will literally always be able to keep up.


\subsection{Inconsistencies}
Interestingly enough writing START and STOP appears to work.
So the actual writing to SPI seems to be correct.

Very weird because it seems like there are two versions of the design.
The one that got made appears to be older and worse. So not really sure what's going on.
Perhaps this is the beginning of a revision 2?
But I also cannot find the altium files for it, only a single pdf remains.
Shame because the newer one has a bunch of LEDs on it that would make this way easier.

So what we know is that write must work. As writing START and STOP commands have
an effect.
What is currently unknown is if the reading and writing register commands work correctly.
I really don't see how they wouldn't because I've hand checked the bits during debugging.
Really the only thing I can think at this stage is that maybe the PIC is sending in 32-bit
mode. That doesn't really make sense since it's configured to 8-bit mode but maybe it
still sends extra or something (this would be very silly).

I cannot think of anything else to check short of soldering to the pins and checking
the physical signals that are being send both ways. I'm sure if I did that I would be able
to verify it almost immediately... Should definitly bring bodge wire on Tuesday and make
use of the good soldering irons, flux, microscopes, and nice oscilloscopes at uni.

Other than that it could also be the power on cycle needs specific lines held low/high
and I just do not have digital access to those pins.

Or worst case the entire board has been designed so badly that the chip is having weird
power issues. Looking at the altium board files it definitly does not look great.
At least there is a lot to include in ADC challenges for my results.


The status word that I am expecting contains the following
`1100 LOFF\_STATP[7:0] LOFF\_STATN[7:0] GPIO[7:4]'
So maybe the received 11000000 could be the beginning of that status word but then I
am not reading any more or something?

GPIO register looks like `DATA[4:1] CONTROL[4:1]' with 0 being outputs and 1 being inputs
for the control section

So I am not able to write the register. I think at this stage what must be wrong is my
register writing/reading.
I think the actual write commands are working
because if I write sleep, wakeup, start, stop, or reset
the chip has the response I would expect it to have.
I am not able to verify SDATAC or RDATAC because the data I am then reading is wrong.
It also doesn't seem to stop it from giving me data if I send either of them.
Maybe I should try RDATA and try to just do a simple read see if that makes any difference.

Otherwise, I think the write byte works so I don't see why writing the read/write register
command then the address of the register is not working.

It could also be that the SDATAC, RDATAC, and RDATA commands do not work for some reason
This would mean that all my attempts to read and write registers is futile because
the chip is not going to respond to those commands as it boots into RDATAC mode.
But even so the chip does not give any readings, just 192 (AKA 11000000) continously
so I have no idea what that is supposed to mean.


\subsection{Solution}
Ok so the issue actually came from the CS line. The line was being driven active for each
command but because the ADC had multi-byte commands it was expecting the CS line to stay
active for the entire duration.
What was instead happening was the CS line was going inactive
and causing the ADC to reset mid command which meant it was only responding to single byte
command hence why RESET, STANDBY, WAKEUP, etc were working correctly.

Issue now is my driver has an issue because I'm reading all 0s for the
ID but on the scope I can see the response is correct.

Issue was that the SPI buffer holds the previous transmitted value so need to clear it once
before reading again to get actual value.

Also need to make sure to use special `write\_cmd()' function as it contains the neccessary
chip select setting/resetting and it will not respond to commands otherwise.
